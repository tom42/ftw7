* glfw wrapper
  * key callbacks
    * Should make window::user_pointer private
    * Should use std::function to model key callbacks at glfw::window level
    * Problem: when we move a window, the user pointer we set is not valid anymore
      => user pointer must be set inside ctors! Ouch? At least I think this is what's just bitten us.
      * Consider this:
        * We construct a window. It sets the user pointer to point at it.
        * The window gets moved. The user pointer is left where it is, but ownership of the GLFWwindow* is transferred.
        => We have now a new glfw::window instance, which holds a GLFWwindow* whose user pointer contains the address of another glfw::window instance that doesn't exist anymore. BAD. VERY BAD.
  * should really make monitor and window ctors private and grant the glfw class friend access...
* This is interesting: http://blogs.msdn.com/b/oldnewthing/archive/2014/08/22/10551964.aspx
  * Possibly we can simply call OpenThread on the main thread and this should ensure that the thread ID is preserved until we CloseThread again.
    That would be incredibly useful for thread checking. Yay?
* ftw7_conemu.dll
  * consider linking the C/C++ runtime statically. We won't have ANY DLL location problems that way, since we're already statically linking GLFW.
* display drivers: stop tinkering around
  * What kind of display modes should we support?
    * windowed
    * fullscreen window
    * real fullscreen (orly?)
  * Scaling modes?
    * Stretch to fit, maintaining aspect ratio
    * No scaling (center on screen)
    * Scale by integer amount and center
  * Attempt to emulate real vga output? (Ninth column)
* Clean up opengl and gdi display drivers:
  * Variable Window width/height
  * Screen width/screen height
  * Fullscreen mode
  * Refresh rate
  * Color depth (?)
  * Alt+Enter for fullscreen/windowed mode switching
* drivers/interface:
  * On the work notebook, ChangeDisplaySettingsEx in fact DOES work => Test this again, perhaps we can make the GDI driver work too.
  * Do a simple fix for cernunnos: don't think there are too many other
    demos that pull off shit like that
* Fixage, hopefully to be applied somewhen:
  * Litterae Finis:
    * Can still quit if ESC is pressed and the console window is active: find out what API function to intercept and make it a no-op
  * Cernunnos:
    * Somehow manages to interfere with the opengl display driver.
    * Fucks up console logging, but then, we should probably not rely on the console for logging.
  * Clockwerck
    * Spurious crashes at end of demo. That's why --no-error-dialogs has been implemented
  * Display drivers: a horrible mess they are, that's what they are.
  * Whoops:
    "No window classes registered by a DLL are unregistered when the DLL is unloaded.
    A DLL must explicitly unregister its classes when it is unloaded."
    => Well...that's when the DLL is dynamically unloaded using FreeLibrary.
    => Window classes are unregistered when a process terminates. There's
       some blog entry from raymond chen on that subject.
    => Document this somewhere in the gdi display driver and be done with it.
  * Some logging facility
    * What we have is probably already pretty good
    * Add a mechanism to add certain messages only once
      * Doesn't need to be all THAT thread-safe =)
* Damit:
  * Features for a reimplementation
    * logging (to file. The emulation DLL should leave the console alone, for our own sanity)
* Here's a list of functions prototype I is hooking. Check them and implement them if it makes sense.
  * kernel32
    * CreateConsoleScreenBuffer
    * SetConsoleCursorInfo
    * SetConsoleMode
    * SetConsoleScreenBufferSize
* display driver handling is a mess
  * Somewhere there's a factory function that creates display drivers from display driver codes
  * commandline.cpp contains code to map from strings to display driver codes.
* string.cpp: some stuff in there could do with some unit testing, and also optimizing (string lengths are determined multiple times)
* Log output to console: this is sometimes tricky.
  * Console applications work out of the box.
  * Magrathea: Succeeds with the following steps
    * Pass the launcher's process ID to the emulation DLL
    * Inside the emulation DLL
      * Use AttachConsole to attach to the parent process' console
      * Use WriteConsole(W) to write to the console
      * Be careful, though: MSDN says:
        "WriteConsole fails if it is used with a standard handle that is redirected to a file.
        If an application processes multilingual output that can be redirected, determine whether
        the output handle is a console handle (one method is to call the GetConsoleMode function
        and check whether it succeeds). If the handle is a console handle, call WriteConsole.
        If the handle is not a console handle, the output is redirected and you should call
        WriteFile to perform the I/O."...oh well.
