* Clean up opengl and gdi display drivers:
  * Variable Window width/height
  * Screen width/screen height
  * Fullscreen mode
  * Refresh rate
  * Color depth (?)
  * Alt+Enter for fullscreen/windowed mode switching
* drivers/interface:
  * On the work notebook, ChangeDisplaySettingsEx in fact DOES work => Test this again, perhaps we can make the GDI driver work too.
  * Do a simple fix for cernunnos: don't think there are too many other
    demos that pull off shit like that
* Fixage, hopefully to be applied somewhen:
  * Cernunnos:
    * Somehow manages to interfere with the opengl display driver.
	* Fucks up console logging, but then, we should probably not rely on the console for logging.
  * Clockwerck
    * Spurious crashes at end of demo. That's why --no-error-dialogs has been implemented
  * Display drivers: a horrible mess they are, that's what they are.
  * Whoops:
    "No window classes registered by a DLL are unregistered when the DLL is unloaded.
    A DLL must explicitly unregister its classes when it is unloaded."
    => Well...that's when the DLL is dynamically unloaded using FreeLibrary.
    => Window classes are unregistered when a process terminates. There's
       some blog entry from raymond chen on that subject.
    => Document this somewhere in the gdi display driver and be done with it.
  * Some logging facility
    * What we have is probably already pretty good
    * Add a mechanism to add certain messages only once
      * Doesn't need to be all THAT thread-safe =)
* Damit:
  * Features for a reimplementation
    * logging (to file. The emulation DLL should leave the console alone, for our own sanity)
      * Log demo duration
* Here's a list of functions prototype I is hooking. Check them and implement them if it makes sense.
  * kernel32
    * CreateConsoleScreenBuffer
    * SetConsoleCursorInfo
    * SetConsoleMode
    * SetConsoleScreenBufferSize
* display driver handling is a mess
  * Somewhere there's a factory function that creates display drivers from display driver codes
  * commandline.cpp contains code to map from strings to display driver codes.
* string.cpp: some stuff in there could do with some unit testing, and also optimizing (string lengths are determined multiple times)
* Log output to console: this is sometimes tricky.
  * Console applications work out of the box.
  * Magrathea: Succeeds with the following steps
    * Pass the launcher's process ID to the emulation DLL
	* Inside the emulation DLL
	  * Use AttachConsole to attach to the parent process' console
	  * Use WriteConsole(W) to write to the console
	  * Be careful, though: MSDN says:
	    "WriteConsole fails if it is used with a standard handle that is redirected to a file.
		If an application processes multilingual output that can be redirected, determine whether
		the output handle is a console handle (one method is to call the GetConsoleMode function
		and check whether it succeeds). If the handle is a console handle, call WriteConsole.
		If the handle is not a console handle, the output is redirected and you should call
		WriteFile to perform the I/O."...oh well.
